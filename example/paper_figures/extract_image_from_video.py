#Originally generated by ChatGPT. Modified by Giovanni Franzese. 

import cv2
import numpy as np

# Path to the video file
video_path = "path_to_video_file.mp4"

# Open the video file
cap = cv2.VideoCapture(video_path)

# Define the desired time steps
time_steps = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]

# Initialize the final canvas size
canvas_height = 0
canvas_width = 0

# Create a list to store the overlapped frames
overlapped_frames = []

# Iterate through the time steps and extract frames
for t in time_steps:
    # Calculate the frame position based on time
    frame_pos = int(t * cap.get(cv2.CAP_PROP_FRAME_COUNT))
    
    # Set the frame position
    cap.set(cv2.CAP_PROP_POS_FRAMES, frame_pos)
    
    # Read the frame
    ret, frame = cap.read()
    
    # Convert the frame to grayscale
    gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    
    # Perform image differencing and thresholding
    if prev_frame is not None:
        diff_frame = cv2.absdiff(prev_frame, gray_frame)
        threshold = 30  # Adjust this threshold as needed
        _, thresholded_frame = cv2.threshold(diff_frame, threshold, 255, cv2.THRESH_BINARY)
        
        # Set significantly different pixels to transparent
        non_zero_prev = (prev_frame != 0)  # Pixels that are non-zero in the previous frame
        frame[(thresholded_frame != 0) & non_zero_prev] = [0, 0, 0]  # Set to black
    
    # Update the previous frame
    prev_frame = gray_frame.copy()
    
    # Update the canvas size if necessary
    canvas_height = max(canvas_height, frame.shape[0])
    canvas_width = max(canvas_width, frame.shape[1])
    
    # Check for overlapping frames
    if len(overlapped_frames) > 0:
        mask = np.any(frame != 0, axis=2)  # Mask of non-zero pixels in the current frame
        for overlapped_frame, overlapped_mask in overlapped_frames:
            alpha = np.where(mask & overlapped_mask, 0.5, 1.0)  # Adjust the transparency level
            frame[:, :, 3] = (alpha * 255).astype(np.uint8)  # Set the alpha channel
    
    # Store the current frame and its mask for future comparisons
    overlapped_frames.append((frame.copy(), np.any(frame != 0, axis=2)))

# Create the final canvas
canvas = np.zeros((canvas_height, canvas_width, 4), dtype=np.uint8)

# Iterate through the overlapped frames and overlay them onto the canvas
for frame, _ in overlapped_frames:
    # Overlay the frame onto the canvas
    x = (canvas_width - frame.shape[1]) // 2
    y = (canvas_height - frame.shape[0]) // 2
    canvas[y:y+frame.shape[0], x:x+frame.shape[1]] = frame

# Save the final overlay image
output_path = "output/overlay_image.png"
cv2.imwrite(output_path, canvas)

# Release the video capture object
cap.release()
